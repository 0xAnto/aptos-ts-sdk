// Copyright Â© Aptos Foundation
// SPDX-License-Identifier: Apache-2.0
import { AptosConfig } from "../../../api";
import { Account } from "../../../core";
import { Signer } from "../../../core/signer";
import { RawTransaction } from "../../../transactions/instances";
import { PendingTransactionResponse, UserTransactionResponse, WaitForTransactionOptions } from "../../../types";

/**
 * This is more of a Director in terms of builder design patterns.
 * It is intended to simplify the transaction builder process by making the process sequential and declarative.
 * The flow is as follows:
 *
 * 1. Instantiate the TransactionBuilder by sending in data to construct `RawTransaction`, this data is stored in the class fields to use later:
 *     - rawTransaction: RawTransaction
 *     - in this is a `sender` address, which is used later to
 *
 *
 *
 */
export abstract class TransactionBuilder {
  protected readonly rawTransaction: RawTransaction; // the RawTransaction that is used to create a signing message that is signed by 1 or more signers
  protected readonly aptosConfig: AptosConfig;
  protected senderSigner?: Signer;

  constructor(args: { rawTransaction: RawTransaction; aptosConfig: AptosConfig }) {
    this.rawTransaction = args.rawTransaction;
    this.aptosConfig = args.aptosConfig;
  }

  abstract getInfo(): TransactionBuilderInfo;

  /**
   * If you possess the private key (or have an instance of an `Account`), you can sign the transaction with this function.
   *
   * If you don't have the private key, you can pass in an `AccountAuthenticator`. @see addSignature
   * @param account The local account that will sign the transaction
   */
  abstract sign(signer: Account): void;

  /**
   * This function is used to add to the signature(s) for the transaction.
   * In a dapp context, the `AccountAuthenticator` would be generated by a wallet provider.
   * @param signer This value is created from either the `Account` that will sign the transaction or the `AccountAuthenticator` from an account that has already signed,
   * usually by a wallet provider.
   * @see AccountAuthenticator class
   */
  abstract addSignature(signer: Signer): void;

  /**
   * Once you've gathered all of the signatures, you can submit the transaction to the chain.
   * Once you've submitted the transaction, you can wait for the transaction to complete.
   * @param args.waitForResult If true, the function will wait for the transaction to complete before returning
   * @param args.forSeconds The number of seconds to wait for the transaction to complete
   * @returns PendingTransactionResponse a response that contains the transaction hash and other information about the transaction
   */
  abstract submit(): Promise<PendingTransactionResponse>;
  abstract addWalletSignature(signFeePayerTransaction: SignFeePayerTransactionFunction): Promise<void>;
  abstract waitForResponse(waitForTransactionOptions?: WaitForTransactionOptions): Promise<UserTransactionResponse>;
  abstract submitAndWaitForResponse(
    waitForTransactionOptions?: WaitForTransactionOptions,
  ): Promise<UserTransactionResponse>;
  abstract signSubmitAndWaitForResponse(args: {
    signer: Account;
    waitForTransactionOptions?: WaitForTransactionOptions;
  }): Promise<UserTransactionResponse>;
  // abstract simulateTransaction(args: SimulateTransactionData): Promise<Array<UserTransactionResponse>>;
}
