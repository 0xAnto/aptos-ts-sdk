// Copyright Â© Aptos Foundation
// SPDX-License-Identifier: Apache-2.0

import { Aptos, AptosConfig } from "../../api";
import { Account, AccountAddress } from "../../core";
import { Signer } from "../../core/signer";
import { waitForTransaction } from "../../internal/transaction";
import { submitTransaction } from "../../internal/transactionSubmission";
import { generateRawTransaction } from "../../transactions";
import { AccountAuthenticator } from "../../transactions/authenticator/account";
import { EntryFunction, Identifier, ModuleId, RawTransaction, RawTransactionWithData, TransactionPayload, TransactionPayloadEntryFunction } from "../../transactions/instances";
import { EntryFunctionArgumentTypes, InputGenerateTransactionOptions, InputSimulateTransactionData } from "../../transactions/types";
import { HexInput, PendingTransactionResponse, UserTransactionResponse, WaitForTransactionOptions } from "../../types";
import { Network } from "../../utils/apiEndpoints";
import { Deserializer } from "../deserializer";
import { Serializable, Serializer } from "../serializer";
import { MoveVector } from "./moveStructs";

interface EntryFunctionArgsField {
    [key: string]: EntryFunctionArgumentTypes;
}

// Build the payload for them
export abstract class EntryFunctionPayload extends Serializable {
    abstract args: EntryFunctionArgsField;

    serialize(serializer: Serializer): void {
        Object.keys(this.args).forEach((field) => {
            const value = this.args[field as keyof typeof this.args];
            serializer.serialize(value);
        });
    }
}

// Let's build a flow based around the Dapp itself being the director of this transaction builder pattern.

/**
 * This represents either a RawTransaction or a RawTransactionWithData.
 * It's used to construct an AccountAuthenticator
 * @see AccountAuthenticator
 * @see RawTransaction
 * @see RawTransactionWithData
 */
export interface RawTransactionSigningMessage {
    rawTransaction: RawTransaction;
    secondarySignerAddresses?: Array<AccountAddress>;
    feePayerAddress?: AccountAddress;
}

function getConfigOrNetwork(aptosConfigOrNetwork: AptosConfig | Network): AptosConfig {
    if (aptosConfigOrNetwork instanceof AptosConfig) {
        return aptosConfigOrNetwork;
    }
    return new AptosConfig({ network: aptosConfigOrNetwork });
}

/**
 * This is more of a Director in terms of builder design patterns.
 * It is intended to simplify the transaction builder process by making the process sequential and declarative.
 * The flow is as follows:
 * 
 * 1. Instantiate the TransactionBuilder by sending in data to construct `RawTransaction`, this data is stored in the class fields to use later:
 *     - rawTransaction: RawTransaction
 *     - in this is a `sender` address, which is used later to 
 * 
 * 
 * 
 */
export abstract class TransactionBuilder {
    protected readonly rawTransaction: RawTransaction; // the RawTransaction that is used to create a signing message that is signed by 1 or more signers
    protected readonly aptosConfig: AptosConfig;
    protected senderSigner?: Signer;

    constructor(args: {
        rawTransaction: RawTransaction,
        aptosConfig: AptosConfig,
    }) {
        this.rawTransaction = args.rawTransaction;
        this.aptosConfig = args.aptosConfig;
    }

    abstract getInfo(): TransactionBuilderInfo;

    /**
     * If you possess the private key (or have an instance of an `Account`), you can sign the transaction with this function.
     * 
     * If you don't have the private key, you can pass in an `AccountAuthenticator`. @see addSignature
     * @param account The local account that will sign the transaction 
     */
    abstract sign(signer: Account): void;

    /**
     * This function is used to add to the signature(s) for the transaction.
     * In a dapp context, the `AccountAuthenticator` would be generated by a wallet provider.
     * @param signer This value is created from either the `Account` that will sign the transaction or the `AccountAuthenticator` from an account that has already signed,
     * usually by a wallet provider.
     * @see AccountAuthenticator class
     */
    abstract addSignature(signer: Signer): void;

    /**
     * Once you've gathered all of the signatures, you can submit the transaction to the chain.
     * Once you've submitted the transaction, you can wait for the transaction to complete.
     * @param args.waitForResult If true, the function will wait for the transaction to complete before returning
     * @param args.forSeconds The number of seconds to wait for the transaction to complete
     * @returns PendingTransactionResponse a response that contains the transaction hash and other information about the transaction
     */
    abstract submit(): Promise<PendingTransactionResponse>;
    abstract addWalletSignature(signFeePayerTransaction: SignFeePayerTransactionFunction): Promise<void>;
    abstract waitForResponse(waitForTransactionOptions?: WaitForTransactionOptions): Promise<UserTransactionResponse>;
    abstract submitAndWaitForResponse(waitForTransactionOptions?: WaitForTransactionOptions): Promise<UserTransactionResponse>;
    abstract signSubmitAndWaitForResponse(args: { signer: Account, waitForTransactionOptions?: WaitForTransactionOptions }): Promise<UserTransactionResponse>;
    // abstract simulateTransaction(args: SimulateTransactionData): Promise<Array<UserTransactionResponse>>;
}

export type TransactionBuilderInfo = {
    rawTransaction: RawTransaction,
    aptosConfig: AptosConfig,
    sender: AccountAddress,
    payload: TransactionPayload,
    senderSigner?: Signer,
    feePayerAddress?: AccountAddress,
    feePayerSigner?: Signer,
    secondarySignerAddresses?: Array<AccountAddress>,
    secondarySigners?: Array<Signer>,
    transactionHash?: HexInput,
}

export type CreateTransactionBuilderArgs = {
    sender: AccountAddress,
    payload: TransactionPayload,
    configOrNetwork: AptosConfig | Network,
    options?: InputGenerateTransactionOptions,
};

export type CreateTransactionBuilderWithFeePayerArgs = CreateTransactionBuilderArgs & {
    feePayerAddress: AccountAddress,
};

export type SignFeePayerTransactionFunction = (
    sender: AccountAddress,
    rawTransaction: RawTransaction,
    feePayerAddress: AccountAddress
) => Promise<Signer>;

export class SingleSignerTransactionBuilder extends TransactionBuilder {
    protected senderSigner?: Signer;
    // if fee payer is 0x0, then it's an anonymous fee payer transaction
    private feePayerAddress: AccountAddress = AccountAddress.ZERO;
    private feePayerSigner?: Signer;
    private transactionHash?: HexInput;

    protected constructor(args: CreateTransactionBuilderArgs & { feePayerAddress?: AccountAddress }) {
        const { sender, payload, configOrNetwork, options } = args;
        const config = getConfigOrNetwork(configOrNetwork);
        const rawTransaction = await generateRawTransaction({ sender: sender.toString(), payload: payload as any, aptosConfig: config, options });
        super({
            rawTransaction,
            aptosConfig: config,
        });
        this.feePayerAddress = args.feePayerAddress ?? AccountAddress.ZERO;
    }

    getInfo(): TransactionBuilderInfo {
        return {
            rawTransaction: this.rawTransaction,
            aptosConfig: this.aptosConfig,
            sender: this.rawTransaction.sender,
            payload: this.rawTransaction.payload as any, // TODO: Figure out why it makes you cast this
            senderSigner: this.senderSigner,
            feePayerAddress: this.feePayerAddress,
            feePayerSigner: this.feePayerSigner,
            secondarySignerAddresses: undefined,
            secondarySigners: undefined,
            transactionHash: this.transactionHash,
        };
    }

    static async create(args: CreateTransactionBuilderArgs): Promise<SingleSignerTransactionBuilder> {
        return new SingleSignerTransactionBuilder(args);
    }

    static async createWithFeePayer(args: CreateTransactionBuilderWithFeePayerArgs): Promise<SingleSignerTransactionBuilder> {
        return new SingleSignerTransactionBuilder(args);
    }

    static async createWithAnonymousFeePayer(args: CreateTransactionBuilderArgs): Promise<SingleSignerTransactionBuilder> {
        return new SingleSignerTransactionBuilder(args);
    }

    /**
     * This function needs to be called twice, once by the sender and once by the fee payer.
     * @param signer the signer of the transaction, either the sender or the fee payer.
     */
    sign(signer: Account): void {
        // default to 0x0
        let feePayerAddressToUse = this.feePayerAddress;
        // unless the signer is the fee payer
        if (!signer.accountAddress.equals(this.rawTransaction.sender)) {
            // The fee payer must sign the transaction with themselves as the fee payer,
            // so if the signer is not the sender, then they must be the fee payer.
            // It's possible the fee payer is 0x0, so we need to manually override that
            feePayerAddressToUse = signer.accountAddress;
        }
        const inferredSigner = Signer.fromLocalAccount({ account: signer, rawTransaction: this.rawTransaction, feePayerAddress: feePayerAddressToUse });
        this.addSignature(inferredSigner);
    }

    // Either this or below for dapp context.
    // This one is less explicit, since it requires you get a `Signer` back from a wallet adapter (or an `AccountAuthenticator` that you create a 
    // `Signer` with yourself)
    addSignature(signer: Signer): void {
        if (signer.address == this.feePayerAddress || this.feePayerAddress == AccountAddress.ZERO) {
            this.feePayerSigner = signer;
        } else if (signer.address == this.rawTransaction.sender) {
            this.senderSigner = signer;
        } else {
            throw new Error("The signer address does not match either the sender or the fee payer address.");
        }
    }

    async addWalletSignature(signFeePayerTransaction: SignFeePayerTransactionFunction): Promise<void> {
        // the wallet must implement logic to infer if the feepayer needs to be changed from 0x0 or not
        const signer = await signFeePayerTransaction(this.rawTransaction.sender, this.rawTransaction, this.feePayerAddress);
        this.addSignature(signer);
    }

    async submit(): Promise<PendingTransactionResponse> {
        if (this.senderSigner === undefined || this.feePayerSigner === undefined) {
            throw new Error("You must sign the transaction before submitting it.");
        }
        const response = await submitTransaction({
            aptosConfig: this.aptosConfig,
            transaction: {
                rawTransaction: this.rawTransaction.bcsToBytes(),
            },
            senderAuthenticator: this.senderSigner.authenticator,
            secondarySignerAuthenticators: {
                feePayerAuthenticator: this.feePayerSigner.authenticator,
            }
        });
        return response as PendingTransactionResponse;
    }

    async waitForResponse(waitForTransactionOptions?: WaitForTransactionOptions): Promise<UserTransactionResponse> {
        if (this.transactionHash === undefined) {
            throw new Error("You must submit the transaction before waiting for it.");
        }
        const response = await waitForTransaction({
            transactionHash: this.transactionHash,
            aptosConfig: this.aptosConfig,
            options: waitForTransactionOptions,
        });
        return response as UserTransactionResponse;
    }

    async submitAndWaitForResponse(waitForTransactionOptions?: WaitForTransactionOptions): Promise<UserTransactionResponse> {
        await this.submit();
        const response = await this.waitForResponse(waitForTransactionOptions);
        return response as UserTransactionResponse;
    }

    async signSubmitAndWaitForResponse(args: { signer: Account, waitForTransactionOptions?: WaitForTransactionOptions }): Promise<UserTransactionResponse> {
        const { signer, waitForTransactionOptions } = args;
        this.sign(signer);
        return this.submitAndWaitForResponse(waitForTransactionOptions);
    }
}

export class CreateResourceAccountAndPublishPackage extends SingleSignerTransactionBuilder {
    constructor(args: Omit<CreateTransactionBuilderArgs, "payload"> & {
            seed: Uint8Array,
            metadata: Uint8Array,
            bytecode: Array<Uint8Array>, // each array is the bytecode for a module
    }) {
        super({
            ...args,
            // payload below should really just come from `CreateResourceAccountAndPublishPackagePayload` class in `0x1.ts`
            payload: new TransactionPayloadEntryFunction(new EntryFunction(
                new ModuleId(AccountAddress.ONE, new Identifier("account")),
                new Identifier("create_resource_account_and_publish_package"),
                [],
                [
                    MoveVector.U8(args.seed),
                    MoveVector.U8(args.metadata),
                    new MoveVector(args.bytecode.map((bytecode) => MoveVector.U8(bytecode))),
                ]                
            )),
        });
    }
}

const craappTransactionBuilder = new CreateResourceAccountAndPublishPackage({
    sender: AccountAddress.ONE,
    seed: new Uint8Array(),
    metadata: new Uint8Array(),
    bytecode: [new Uint8Array()],
    configOrNetwork: Network.TESTNET,
    options: {},
}); // with fee payer too?

await craappTransactionBuilder.sign(Account.generate());
await craappTransactionBuilder.signSubmitAndWaitForResponse({ signer: Account.generate() });



const sender = Account.generate();
const feePayer = Account.generate();
const payload = {} as any;
const network = Network.TESTNET;
const options = {} as any;

const myTransaction = await SingleSignerTransactionBuilder.createWithFeePayer({
    sender: sender.accountAddress,
    feePayerAddress: feePayer.accountAddress,
    payload: payload,
    configOrNetwork: network,
    options?: options,
});

myTransaction.sign(sender);
myTransaction.sign(feePayer);
myTransaction.submit();
const response = myTransaction.waitForResponse();


/**
 * For Move entry functions with multiple &signers:
 * public entry fun(signer_1: &signer, signer_2: &signer, ..., signer_n: &signer);
 */
export class MultiSignerTransactionBuilder extends TransactionBuilder {
    public readonly rawTransaction: RawTransaction;
    public readonly rawTransactionWithData: RawTransactionWithData;
    public readonly sender: AccountAddress;
    public readonly secondarySignerAddresses: Array<AccountAddress>; // specified at instantiation, since order matters
    public readonly senderSigner?: Signer;
    public readonly secondarySigners?: Array<Signer>;

    private constructor(args: {
        rawTransaction: RawTransaction,
        sender: AccountAddress,
        secondarySignerAddresses: Array<AccountAddress>,
        senderSigner?: Signer, // you can pass this now or collect it later
        secondarySigners?: Array<Signer>, // you can pass this now or collect it later
    }) {
        super({ ...args });
        const { rawTransaction, sender, secondarySignerAddresses, senderSigner, secondarySigners } = args;
        this.sender = sender;
        this.rawTransaction = rawTransaction;
        this.secondarySigners = secondarySigners;
        this.rawTransactionWithData = deriveTransactionType({
            rawTransaction: this.rawTransaction.bcsToBytes(),
            secondarySignerAddresses: secondarySignerAddresses,
        });
        this.senderSigner = senderSigner;
        this.secondarySignerAddresses = secondarySignerAddresses;
    }
    // this.feePayerAddress = args.feePayerAddress;

    /**
     * Largely the same as @see generateRawTransaction, this function mainly serves to simplify the process by storing the raw transaction in the class fields.
     * 
     * The main difference is that we require *all* of the information up front and store it, that way the developer doesn't have to worry about
     * the rest of the transaction builder flow.
     * 
     * Ideally, this function is wrapped and called solely by auto-generated code that determines how many secondary signers are possibly for a given function, given its abi inputs.
     * 
     * NOTE: The `sender` address passed in will be the first `&signer` in the Move function signature.
     * If there are any secondary `&signer` arguements, their order is determined by the order of the secondary signer addresses input here.
     * @param args.sender The address of the account that will appear as the first `&signer` in the Move function signature
     * @param args.secondarySignerAddresses The addresses of the accounts that will appear as the secondary `&signer` arguments in the Move function signature
     * @param args.feePayerAddress The address of the account that will pay the transaction fee, if unspecified, this will be `0x0`
     * @param args.payload The transaction payload
     * @param args.aptosConfigOrNetwork The AptosConfig or Network that will be used to generate the transaction
     * @param args.options The options that will be used to generate the transaction
     */
    async static create(args: {
        sender: AccountAddress,
        secondarySignerAddresses: Array<AccountAddress>,
        feePayerAddress?: AccountAddress,
        payload: TransactionPayload,
        aptosConfigOrNetwork: AptosConfig | Network,
        options: GenerateTransactionOptions,
    }): Promise<TransactionBuilder> {
        const { sender, payload, aptosConfigOrNetwork, options } = args;
        const aptosConfig = getConfigOrNetwork(aptosConfigOrNetwork);
        const transaction = await buildTransaction({ sender: sender.toString(), payload, aptosConfig, options });
        const deserializer = new Deserializer(transaction.rawTransaction);
        const derivedRawTransaction = deriveTransactionType(transaction);
        const signingMessage = await getSigningMessage(derivedRawTransaction);
        const rawTransaction = RawTransaction.deserialize(deserializer);
        const secondarySignerAddresses = args.secondarySignerAddresses;
        const feePayerAddress = args.feePayerAddress;
        const signingMessage = signingMessage;

        return new MultiSignerTransactionBuilder({
            rawTransaction,
            sender,
            signingMessage,
            secondarySignerAddresses,
            feePayerAddress,
        });
    }
}
